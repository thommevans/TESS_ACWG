import pdb, sys, os, time, requests, json
import numpy as np
import pandas as pd
import pickle
import matplotlib.pyplot as plt
try:
    import pysynphot
    pysynphotImport = True
except:
    pysynphotImport = False
import math
from urllib.parse import quote as urlencode

"""
readStellarTrack()
planetMassFromRadius()
solarSystem()
computeTSM()
"""

RSUN_SI = 6.955e8
MSUN_SI = 1.9889e30
MJUP_SI = 1.8986e27
MEARTH_SI = 5.9723e24
RJUP_SI = 7.149e7
REARTH_SI = 6.371e6
AU_SI = 1.496e11
GRAV_SI = 6.67428e-11 # gravitational constant in m^3 kg^-1 s^-2



def generateSmallFile_Kunimoto2022( ipath='', framework='ACWG', \
                                    RpRE_grid=[], TeqK_grid=[] ):
    """
    Standalone routine for extracting the required information
    from the full 342MB file containing the yields from the 
    Kunimoto et al (2022) simulations.

    Adapted from a python notebook shared by Michelle Kunimoto.
    ipath points to the planets_with_tsm.csv file shared by Michelle Kunimoto,
    which is not included in the code repository because it is 324MB.
    """

    print( '\nReading:\n{0}'.format( ipath ) )
    all_sim = pd.read_csv( ipath, index_col=False )
    print( 'Done.\n' )
    
    def get_mean( data ):
        return int( np.round( np.mean( data ) ) )

    def get_std( data ):
        return int( np.round( np.std( data ) ) )

    year = 'y7'
    nsim = 100
    #RpGrid1 = np.arange( 0.2, 5.2, 0.2 )
    #RpGrid2 = np.arange( RpGrid1.max()+0.5, 20.5, 0.5 )
    #RpGrid = np.concatenate( [ RpGrid1, RpGrid2 ] )
    #TeqGrid = np.arange( 100, 3200, 100 )
    nR = len( RpRE_grid )-1
    nT = len( TeqK_grid )-1
    ntop = 5
    topTSM = np.nan*np.ones( [ nsim, ntop, nR, nT ] )
    topESM = np.nan*np.ones( [ nsim, ntop, nR, nT ] )
    print( '\nBinning TSM and ESM values across {0} simulations'.format( nsim ) )
    for k in range( nsim ):
        print( '... simulation {0:.0f} of {1:.0f}'.format( k+1, nsim ) )
        sub = all_sim[(all_sim['sim'] == k) & all_sim[year]]
        TeqK = sub['Teq'].values
        RpRE = sub['Rp'].values
        TSM = sub['TSM'].values
        ESM = sub['ESM'].values
        for i in range( nR ):
            ixsi = ( RpRE>=RpRE_grid[i] )*( RpRE<RpRE_grid[i+1] )
            for j in range( nT ):
                ixsj = ( TeqK>=TeqK_grid[j] )*( TeqK<TeqK_grid[j+1] )
                ixs = ixsi*ixsj
                TSMij = TSM[ixs]
                ESMij = ESM[ixs]
                TSMij = TSMij[np.isfinite( TSMij )]
                ESMij = ESMij[np.isfinite( ESMij )]
                nTSM = min( [ len( TSMij ), ntop ] )
                nESM = min( [ len( ESMij ), ntop ] )
                if nTSM>0:
                    for c in range( nTSM ):
                        topTSM[k,c,i,j] = TSMij[np.argsort( TSMij )[::-1]][c]
                if nESM>0:
                    for c in range( nESM ):
                        topESM[k,c,i,j] = ESMij[np.argsort( ESMij )[::-1]][c]
    zout = { 'TSM':topTSM, 'ESM':topESM, \
             'RpRE_grid':RpRE_grid, 'TeqK_grid':TeqK_grid }
    odir = os.path.dirname( __file__ )
    opath = os.path.join( odir, 'datafileTESS_Kunimoto2022_{0}.pkl'.format( framework ) )
    ofile = open( opath, 'wb' )
    pickle.dump( zout, ofile )
    ofile.close()
    print( '\nSaved:\n{0}\n'.format( opath ) )
    return None

def readKunimoto2022():
    """
    Reads the pickle file generated by the 
    generateSmallFile_Kunimoto2022() routine.
    """
    idir = os.path.dirname( __file__ )
    ipath = os.path.join( idir, 'datafileTESS_Kunimoto2022.pkl' )
    ifile = open( ipath, 'rb' )
    z = pickle.load( ifile )
    ifile.close()
    return z

def medianSimulation_Kunimoto2022( surveyName, SMFlag ):
    """
    Takes the Kunimoto et al (2022) TSM and ESM best values
    from the default bins produced by:
      generateSmallFile_Kunimoto2022()
    and rebins those into new TSM and ESM arrays on the grid
    defined by the input arguments RpRE_edges and TeqK_edges.
    
    Output is TSM and ESM arrays with size:
       [ ntop, nRp, nTeq ] where ntop is the number of top TSM/ESM
    values within each bin, nRp is the number of RpRE bins defined 
    by RpRE_edges, and nTeq is the number of Teq bins defined by
    TeqK_edges.
    """
    idir = os.path.dirname( __file__ )
    ipath = os.path.join( idir, 'datafileTESS_Kunimoto2022_{0}.pkl'.format( surveyName ) )
    if os.path.isfile( ipath )==False:
        print( 'File:\n{0}\ndoes not exist!'.format( ipath ) )
        print( 'You need to run surveySetup.prepPredicted() first and it' )
        print( 'requires the 324MB file "planets_with_tsm.csv" as input.' )
        pdb.st_trace()
    ifile = open( ipath, 'rb' )
    z = pickle.load( ifile )
    ifile.close()
    sm = z[SMFlag]
    nsim, ntop, nR, nT = np.shape( sm )
    med = np.nan*np.ones( [ ntop, nR, nT ] )
    for c in range( ntop ):
        for i in range( nR ):
            for j in range( nT ):
                v = sm[:,c,i,j]
                med[c,i,j] = np.median( v[np.isfinite(v)] )
    return med

def delete():
    nR = len( RpRE_edges )-1
    nT = len( TeqK_edges )-1
    z = readKunimoto2022()
    nsim, ntop, nR0, nT0 = np.shape( z['topTSM'] )
    nsim, ntop, nR0, nT0 = np.shape( z['topESM'] )
    RpEdges0 = z['RpRE_grid']
    TeqEdges0 = z['TeqK_grid']
    Rp0 = 0.5*( RpEdges0[:-1] + RpEdges0[1:] )
    Teq0 = 0.5*( TeqEdges0[:-1] + TeqEdges0[1:] )
    TSM = np.nan*np.ones( [ ntop, nR, nT ] )
    ESM = np.nan*np.ones( [ ntop, nR, nT ] )
    for c in range( ntop ):
        # Loop over the radius bins for the new binning:
        for i in range( nR ):
            # Find radius bins from old binning that fall within new binning:
            ixsi = ( Rp0>=RpRE_edges[i] )*( Rp0<RpRE_edges[i+1] )
            # Loop over the temperature bins for the new binning:
            for j in range( nT ):
                # Find temperature bins from old binning that fall within new binning:
                ixsj = ( Teq0>=TeqK_edges[j] )*( Teq0<TeqK_edges[j+1] )
                print( i, j, ixsi.sum(), ixsj.sum() )
                # Determine if any of the old bins fall within this new bin:
                if ( ixsi.sum()>0 )*( ixsj.sum()>0 ):
                    TSMcij = z['topTSM'][:,c,:,:][:,ixsi,:][:,:,ixsj]
                    ESMcij = z['topESM'][:,c,:,:][:,ixsi,:][:,:,ixsj]
                    nsim, nRcij, nTcij = np.shape( TSMcij )
                    # Determine the finite medians of the old bins that fall within
                    # the new bin, where the median is across the simulations:
                    TSMcij_med = np.nan*np.ones( [ nRcij, nTcij ] )
                    ESMcij_med = np.nan*np.ones( [ nRcij, nTcij ] )
                    for r in range( nRcij ):
                        for t in range( nTcij ):
                            y = TSMcij[:,r,t].flatten()
                            y = y[np.isfinite(y)]
                            if len( y )>0:
                                TSMcij_med[r,t] = np.median( y )
                            y = ESMcij[:,r,t].flatten()
                            y = y[np.isfinite(y)]
                            if len( y )>0:
                                ESMcij_med[r,t] = np.median( y )
                    # Take the maximum of the finite medians falling within the new bin:
                    TSM[c,i,j] = np.max( TSMcij_med[np.isfinite( TSMcij_med )] )
                    ESM[c,i,j] = np.max( ESMcij_med[np.isfinite( ESMcij_med )] )
    return { 'TSM':TSM, 'ESM':ESM }
                 
def plotKunimoto():
    """
    Plots Kunimoto 
    """
    z = readKunimoto2022()
    TSMarr = z['topTSM']
    ESMarr = z['topESM']
    nsim, ntop, nR, nT = np.shape( TSMarr )
    TSM = np.zeros( [ ntop, nR-1, nT-1 ] )
    ESM = np.zeros( [ ntop, nR-1, nT-1 ] )
    for c in range( ntop ):
        for i in range( nR-1 ):
            for j in range( nT-1 ):
                ixsT = np.isfinite( TSMarr[:,c,i,j] )
                ixsE = np.isfinite( ESMarr[:,c,i,j] )
                # Take median across all simulations:
                if ixsT.sum()>0:
                    TSM[c,i,j] = np.median( TSMarr[:,c,i,j][ixsT] )
                if ixsE.sum()>0:
                    ESM[c,i,j] = np.median( ESMarr[:,c,i,j][ixsE] )
    plt.figure()
    plt.imshow( TSM[0,:,:], interpolation='nearest', aspect='auto' )
    plt.colorbar()
    plt.title( 'TSM (1st)' )
    plt.figure()
    plt.imshow( TSM[-1,:,:], interpolation='nearest', aspect='auto' )
    plt.colorbar()
    plt.title( 'TSM (5th)' )
    plt.figure()
    plt.imshow( ESM[0,:,:], interpolation='nearest', aspect='auto' )
    plt.colorbar()
    plt.title( 'ESM (1st)' )
    return None
    

def getBestInClassColor( i ):
    """
    """
    if i==1: # 'Green' = confirmed, has >5-sig mass measurement
        backgroundColor = np.array( [178,223,138] )/256.
    elif i==2: # 'Yellow' = confirmed, lacking >5-sigma mass measurement
        backgroundColor = np.array( [255,237,160] )/256.
    elif i==3: # 'Orange' = unconfirmed, mass estimated, passes Kempton threshold
        backgroundColor = np.array( [253,191,111] )/256. 
    elif i==4: # 'Red' = unconfirmed, mass estimated, does NOT pass Kempton threshold
        backgroundColor = np.array( [251,154,153] )/256.
    else:
        pdb.set_trace()
    return backgroundColor

def getBestInClassColor_ORIGINAL( i ):
    if i==1:
        backgroundColor = np.array( [178,223,138] )/256. # 'Green'
    elif i==2:
        backgroundColor = np.array( [253,191,111] )/256. # 'Orange'
    elif i==3:
        backgroundColor = np.array( [251,154,153] )/256. # 'Red'
    else:
        pdb.set_trace()
    return backgroundColor


def writeToGridCell( ax, plNames, nwrite, y0, dy, ixs, pl, plTESS, TstarK, TOIGrid, SMFlag, \
                     plDict, SMVals, top5SM, ASCII, bestInClass, sMass, xtxt, xtxtR, text_fs, xsymb ):
    """
    This is a VERY hacked up routine with a stupid-long argument list, created to handle the
    BestInClass plots, because it does an additional sorting operation within each grid cell
    according to the mass status of the planet. In the future, this should be cleaned up...

    2022-08-30:
    Been requested (by Eliza) not to sort according to mass status, so maybe
    this input argument list doesn't have to be so long? Can't remember what
    the hacking comment above referred to though.

    SMVals = the actual TSM/ESM values
    top5SM = the top 5 predicted TSM/ESM values
    """
    ms = 8
    predSM = top5SM.min()
    
    plStrs = []
    SMStrs = []
    TstarKs = []
    for k in range( nwrite ): #For each planet (max 5)
        plStr = pl[ixs][k].replace( ' ', '' )
        if TOIGrid==True: # because all TOIs are candidates on Exoplanet Archive
            unconfirmedTOI = True
        elif ( plStr=='TOI-' )*( plStr not in plTESS ):
            # Because BestInClass has confirmed planets with names
            # of the form TOI-XXX, which we want to print in full,
            # and also unconfirmed TOIs, for which we only want to
            # print the TOI number:
            unconfirmedTOI = True
        else:
            unconfirmedTOI = False
        if TOIGrid==True:
            t1 = time.time()
            if SMFlag=='TSM':
                SMUnc = estimateUncertaintyTSM( plDict, ixs, k )
            elif SMFlag=='ESM':
                SMUnc = estimateUncertaintyESM( plDict, ixs, k )
            plStr = '{0}'.format( plStr )
            SMStr = '[{0:.0f}(-{1:.0f},+{2:.0f})]'\
                    .format( SMVals[ixs][k], SMUnc[0], SMUnc[1] )
            t2 = time.time()
        else:
            SMStr = '[{0:.0f}]'.format( SMVals[ixs][k] )
        if SMVals[ixs][k] >= predSM:
            plStr += '*'
        plNames.append( plStr )
        SMStrs += [ SMStr ]
        if not ASCII:

            # If this is a TOI grid plot, remove the
            # redundant prefix and suffix:
            if TOIGrid==True:
                plStr = plStr.replace( 'TOI-', '' )
                ix1 = plStr.find( '(' )
                ix2 = plStr.find( ')' )
                plStr = plStr[:ix1] + plStr[ix2+1:]
            elif ( bestInClass==True )*unconfirmedTOI:
                if plStr[:4]=='TOI-':
                    plStr = plStr.replace( 'TOI-', '' )
                    ix1 = plStr.find( '(' )
                    ix2 = plStr.find( ')' )
                    plStr = plStr[:ix1] + plStr[ix2+1:]
            plStrs += [ plStr ]
            TstarKs += [ TstarK[ixs][k] ]

    if not ASCII:
        # Edit text to write on axes, order according to
        # mass status if best-in-class:
        plStrs = np.array( plStrs, dtype=str )
        SMStrs = np.array( SMStrs, dtype=str )
        TstarKs = np.array( TstarKs, dtype=float )
        if bestInClass==True:
            # UP TO HERE 30/8/2022 = NEED TO WORK OUT
            # HOW TO ENSURE THAT OUTPUT IS PRINTED IN ORDER
            # OF RANKED TSM/ESM... ? MAY NEED TO PASS TSM/ESM
            # VALUES IN AS ANOTHER ARRAY, SIMILAR TO THE
            # SMASS ARRAY...
            #ixsWrite = np.argsort( sMass[ixs] )
            #ixsWrite = np.argsort( SMVals[ixs] )
            ixsWrite = np.arange( nwrite )
            #print( 'SMVals', SMVals )
            #print( 'top5SM', top5SM )
            #pdb.set_trace()
            plStrs = plStrs[ixsWrite]
            SMStrs = SMStrs[ixsWrite]
            TstarKs = TstarKs[ixsWrite]
            sMassOrdered = sMass[ixs][ixsWrite]
            #print( plStrs )
            #pdb.set_trace()
        for k in range( nwrite ):
            ytxt = y0-k*dy
            plStr = plStrs[k]
            SMStr = SMStrs[k]
            nStr = len( plStr )
            fullStr = '{0} {1}'.format( plStr, SMStr )

            # Silver if APC or CP
            if ( plStr.find( '(APC' )>0 )+( plStr.find( '(CP)' )>0 ): 
                c = 'Silver'
                wt = 'normal'
            else: # Black if PC
                c = 'Black'
                wt = 'normal'
            if plTESS != None:
                plStrMatch = plStr.split(' ')[0].replace( '*', '' )
                if plStrMatch in plTESS:
                    wt = 'bold'
            if TOIGrid==True:
                wt = 'normal'
            if bestInClass==True:
                bc = getBestInClassColor( sMassOrdered[k] )
            else:
                bc = 'none'
            ck = getStarColor( TstarKs[k] )
            if ax is not None: # if ax is None, just want the plNames output
                ax.text( xtxt, ytxt, fullStr, fontsize=text_fs, \
                         weight=wt, color=c, backgroundcolor=bc, \
                         horizontalalignment='left', verticalalignment='center' )
                ax.plot( [xsymb], [ytxt], 'o', ms=ms, mec=ck, mfc=ck )
    for i in range( 5 ):
        ytxt = y0-i*dy
        SMstr = '[{0:.0f}]'.format( top5SM[i] )
        if ax is not None: # if ax is None, just want the plNames output
            if bestInClass==True:
                ax.text( xtxtR, ytxt, SMstr, fontsize=text_fs, \
                         weight=wt, color='Purple', backgroundcolor='none', \
                         horizontalalignment='right', verticalalignment='center' )
        
    return plNames


def legendBestInClass( fig ):
    bc = {}
    for i in [1,2,3,4]:
        bc[i] = getBestInClassColor( i )
    lab = { 1:'Confirmed, has $>5\\sigma$ mass', \
            2:'Confirmed, lacking $>5\\sigma$ mass', \
            3:'Unconfirmed TOI, pass threshold', 
            4:'Unconfirmed TOI, fail threshold' }
    dy = 0.04
    ytxt0 = 0.96
    xtxtL = 0.6
    xtxtR = xtxtL + ( len( lab[2] )+10 )*0.0045 # 0.3
    ytxt = { 1:ytxt0, 2:ytxt0-dy, 3:ytxt0, 4:ytxt0-dy }
    xtxt = { 1:xtxtL, 2:xtxtL, 3:xtxtR, 4:xtxtR }
    ks = [1,2,3,4]
    for i in range( 4 ):
        #print( ks[i], xtxt )
        k = ks[i]
        fig.text( xtxt[k], ytxt[k], lab[k], fontsize=14, \
                  weight='normal', color='Black', backgroundcolor=bc[k], \
                  horizontalalignment='left', verticalalignment='center' )
        #xtxt += ( len( lab[i] )+10 )*0.005
    return None


def combineConfirmedAndTOIs( plDictConfirmed, plDictTOIs ):
    keysC = list( plDictConfirmed.keys() )
    keysT = list( plDictTOIs.keys() )
    nkeysT = len( keysT )
    ignoreKeys = [ 'Tmag', 'TICID', 'TeqK_exofop', 'RA_hr' ]
    zCombined = {}
    nT = len( plDictTOIs['planetName'] )
    #ixx = (plDictConfirmed['planetName']=='KELT-20 b' )
    #print( np.sum( ixx ) )
    #pdb.set_trace()
    nC = len( plDictConfirmed['planetName'] )
    nansC = np.nan*np.ones( nC )
    for i in range( nkeysT ):
        k = keysT[i]
        if k not in ignoreKeys:
            if k in keysC:
                zCombined[k] = np.concatenate( [ plDictConfirmed[k], plDictTOIs[k] ] )
            elif k=='RpUncRE':
                lSigC = np.abs( plDictConfirmed['RpLsigRE'] )
                uSigC = np.abs( plDictConfirmed['RpUsigRE'] )
                RpUncC = np.max( np.column_stack( [ lSigC, uSigC ] ), axis=1 )
                zCombined[k] = np.concatenate( [ RpUncC, plDictTOIs[k] ] )
            else:
                zCombined[k] = np.concatenate( [ nansC, plDictTOIs[k] ] )
    # TESS-discovered *confirmed* planets are 1, all others (including non-confirmed
    # TOIs) are 0:
    zCombined['confirmedTESS'] = np.concatenate( [ plDictConfirmed['TESS'], \
                                                   np.zeros( nT ) ] )
    # Indexes to identify four subgroups:
    #  1 = Confirmed, with >5-sigma mass.
    #  2 = Confirmed, without >5-sigma mass.
    #  3 = TOIs, only mass is an estimate, passes Kempton threshold
    #  4 = TOIs, only mass is an estimate, does *not* pass Kempton threshold
    mC = np.ones( nC, dtype=int )
    mVal = plDictConfirmed['MpValME']
    mUnc = plDictConfirmed['MpLsigME']
    nsigC = np.abs( mVal/mUnc )
    mC[(nsigC<5)+(np.isfinite( nsigC )==False)] = 2
    # Split between TOIs with estimated masses that pass the minimum TSM/ESM
    # thresholds (=3) and those that don't pass the thresholds (=4):
    mT = 3*np.ones( nT, dtype=int ) # 
    mT[plDictTOIs['thresholdPass']==0] = 4
    # Combine confirmed planets and unconfirmed TOIs:
    zCombined['statusMass'] = np.concatenate( [ mC, mT ] )
    return zCombined

def combineConfirmedAndTOIs_ORIGINAL( plDictConfirmed, plDictTOIs ):
    keysC = list( plDictConfirmed.keys() )
    keysT = list( plDictTOIs.keys() )
    nkeysT = len( keysT )
    ignoreKeys = [ 'Tmag', 'TICID', 'TeqK_exofop', 'RA_hr' ]
    zCombined = {}
    nT = len( plDictTOIs['planetName'] )
    nC = len( plDictConfirmed['planetName'] )
    nansC = np.nan*np.ones( nC )
    for i in range( nkeysT ):
        k = keysT[i]
        if k not in ignoreKeys:
            if k in keysC:
                zCombined[k] = np.concatenate( [ plDictConfirmed[k], plDictTOIs[k] ] )
            elif k=='RpUncRE':
                lSigC = np.abs( plDictConfirmed['RpLsigRE'] )
                uSigC = np.abs( plDictConfirmed['RpUsigRE'] )
                RpUncC = np.max( np.column_stack( [ lSigC, uSigC ] ), axis=1 )
                zCombined[k] = np.concatenate( [ RpUncC, plDictTOIs[k] ] )
            else:
                zCombined[k] = np.concatenate( [ nansC, plDictTOIs[k] ] )
    # TESS-discovered *confirmed* planets are 1, all others (including non-confirmed
    # TOIs) are 0:
    zCombined['confirmedTESS'] = np.concatenate( [ plDictConfirmed['TESS'], \
                                                   np.zeros( nT ) ] )
    # Indexes to identify three subgroups:
    #  1 = Confirmed, with >5-sigma mass.
    #  2 = Confirmed, without >5-sigma mass.
    #  3 = TOIs, without any mass
    mC = np.ones( nC, dtype=int )
    mVal = plDictConfirmed['MpValME']
    mUnc = plDictConfirmed['MpLsigME']
    nsigC = np.abs( mVal/mUnc )
    mC[(nsigC<5)+(nsigC==np.nan)] = 2 
    mT = 3*np.ones( nT, dtype=int )
    zCombined['statusMass'] = np.concatenate( [ mC, mT ] )
    return zCombined

def applyPreCutsTOIs( z, preCutsFunc, obsSample, limitsRA_hr, limitsDec_deg, onlyPCs=True ):
    n0 = len( z['planetName'] )
    ixs0, cutStr, titleStr = preCutsFunc( z, obsSample )
    # Exclude targets outside the RA limits:
    RAStr, RAMin_hr, RAMax_hr = processRARestriction( limitsRA_hr[0], limitsRA_hr[1] )
    ixsRA = ( z['RA_hr'][ixs0]>=RAMin_hr )*( z['RA_hr'][ixs0]<=RAMax_hr )
    # Exclude targets outside the Dec limits:
    DecStr, DecMin_deg, DecMax_deg = processDecRestriction( limitsDec_deg[0], \
                                                            limitsDec_deg[1] )
    ixsDec = ( z['Dec_deg'][ixs0]>=DecMin_deg )*( z['Dec_deg'][ixs0]<=DecMax_deg )
    RADecStr = '{0}\n{1}\nNo bright limits have been applied\n'.format( RAStr, DecStr )
    # Exclude targets with large radius uncertainties:
    RpUncMax = 0.25*z['RpValRE'] # Rp uncertainties <25% of radius value
    RpUncMax[RpUncMax<1] = 1 # except if that's <1RE, then set to 1RE
    ixsRp = ( z['RpUncRE']<RpUncMax ) # only keep those with Rp uncertainties in this range
    print( '\nDiscarding {0:.0f} (out of {1:.0f}) TOIs due to large ExoFOP radius uncertainties\n'\
           .format( len( ixsRp )-ixsRp.sum(), len( ixsRp ) ) )
    if onlyPCs == True:
        ixsPCs = ( [i[-4:]=='(PC)' for i in z['planetName'][ixs0]] )
        ixs = np.arange( n0 )[ixs0][ixsRA*ixsDec*ixsRp*ixsPCs]
    else:
        ixs = np.arange( n0 )[ixs0][ixsRA*ixsDec*ixsRp]
    # Apply cuts to all dictionary arrays:
    for k in list( z.keys() ):
        z[k] = z[k][ixs]
    return z, cutStr, titleStr, RADecStr


def estimateUncertaintyTSM( plDict, ixs, k ):
    """
    Monte Carlo estimates for TSM uncertainties.
    
    Samples Gaussian distributions for Rp and Rs.
    Holds Teq, Mp, and Jmag fixed.
    """
    RsRS = plDict['RsRS'][ixs][k]
    sigRsRS = plDict['RsUncRS'][ixs][k]
    if np.isnan( sigRsRS ):
        sigRsRS = 0.2*RsRS # arbitrarily set to 20% of radius value SMTP Error (220): Authentification failed
    RpRE = plDict['RpValRE'][ixs][k]
    sigRpRE = plDict['RpUncRE'][ixs][k]
    MpME = plDict['MpValME'][ixs][k]
    Jmag = plDict['Jmag'][ixs][k]
    TeqK = plDict['TeqK'][ixs][k]
    TstarK = plDict['TstarK'][ixs][k]
    aRs = plDict['aRs'][ixs][k]
    TSM = plDict['SM'][ixs][k]

    n = 3000
    zMp = MpME*np.ones( n ) #0.5*MpME + MpME*np.random.random( n )
    zRp = RpRE + sigRpRE*np.random.randn( n )
    zRs = RsRS + sigRsRS*np.random.randn( n )
    # Ensure that the minimum Rp and Rs values are
    # small positive numbers (i.e. not negative):
    zRp[zRp<0.05] = 0.05
    zRs[zRs<0.05] = 0.05
    zTeqK = TeqK*np.ones( n )
    zJmag = Jmag*np.ones( n )
    zTSM = computeTSM( zRp, zMp, zRs, zTeqK, zJmag )

    ixs0 = ( np.isnan(zTSM)==False )
    if np.sum( ixs0 )<100:
        pdb.set_trace()
    zTSM = zTSM[ixs0]
    n0 = len( zTSM )
    n34 = int( 0.34*n0 )
    dTSM = zTSM - np.median( zTSM )
    
    ixsL = ( dTSM<0 )
    dTSML = np.abs( dTSM[ixsL] )
    sigLowTSM = dTSML[np.argsort(dTSML)][n34]
    
    ixsU = ( dTSM>=0 )
    dTSMU = np.abs( dTSM[ixsU] )
    sigUppTSM = dTSMU[np.argsort(dTSMU)][n34]
    
    #sigLowTSM = TSM - zTSM.min()
    #sigUppTSM = zTSM.max() - TSM    
    sigTSM = [ sigLowTSM, sigUppTSM ]
    
    return sigTSM


def estimateUncertaintyESM( plDict, ixs, k ):
    """
    Monte Carlo estimates for ESM uncertainties.
    
    Samples Gaussian distributions for Rp and Rs.
    Holds Teq, Tstar, and Kmag fixed.
    """
    
    RsRS = plDict['RsRS'][ixs][k]
    sigRsRS = plDict['RsUncRS'][ixs][k]
    if np.isnan( sigRsRS ):
        sigRsRS = 0.2*RsRS # arbitrarily set to 20% of radius value 
    RpRE = plDict['RpValRE'][ixs][k]
    sigRpRE = plDict['RpUncRE'][ixs][k]
    Kmag = plDict['Kmag'][ixs][k]
    TeqK = plDict['TeqK'][ixs][k]
    TstarK = plDict['TstarK'][ixs][k]
    ESM = plDict['SM'][ixs][k]

    n = 3000
    zRp = RpRE + sigRpRE*np.random.randn( n )
    zRs = RsRS + sigRsRS*np.random.randn( n )
    # Ensure that the minimum Rp and Rs values are
    # small positive numbers (i.e. not negative):
    zRp[zRp<0.05] = 0.05
    zRs[zRs<0.05] = 0.05
    zTeqK = TeqK*np.ones( n )
    zTstarK = TstarK*np.ones( n )
    zKmag = Kmag*np.ones( n )
    zRpRs = ( zRp*REARTH_SI )/( zRs*RSUN_SI )
    zESM = computeESM( zTeqK, zRpRs, zTstarK, zKmag )

    ixs0 = ( np.isnan(zESM)==False )
    if np.sum( ixs0 )<100:
        pdb.set_trace()
    zESM = zESM[ixs0]
    n0 = len( zESM )
    n34 = int( 0.34*n0 )
    dESM = zESM - np.median( zESM )
    
    ixsL = ( dESM<0 )
    dESML = np.abs( dESM[ixsL] )
    sigLowESM = dESML[np.argsort(dESML)][n34]
    
    ixsU = ( dESM>=0 )
    dESMU = np.abs( dESM[ixsU] )
    sigUppESM = dESMU[np.argsort(dESMU)][n34]
    
    sigESM = [ sigLowESM, sigUppESM ]
    
    return sigESM



def applyPreCutsConfirmed( z, preCutsFunc, obsSample, limitsRA_hr, limitsDec_deg ):
    """
    Note that limitsRA_hr and limitsDec_deg haven't been used for Confirmed yet, 
    but could be, and are currently implemented for TOIs.
    """
    
    ixs, cutStr, titleStr = preCutsFunc( z, obsSample )
    RADecStr = '' # not yet implemented for Confirmed (?), only TOIs...
    print( '{0:.0f} planets have mass measurements or estimates'.format( len( ixs ) ) )
    print( 'and orbit stars with radii 0.05-10 R_Sun' )
    # Apply cuts to all dictionary arrays:
    for k in list( z.keys() ):
        z[k] = z[k][ixs]
    return z, cutStr, titleStr, RADecStr


def photBands( makePlot=False ):
    idir = os.path.dirname( __file__ )
    tessPath = os.path.join( idir, 'tess-response-function-v2.0.csv' )
    Vband = np.loadtxt( os.path.join( idir, 'Bessel_V.dat' ) )
    Vband[:,0] /= 1e4 # convert from Angstrom to micron.
    Iband = np.loadtxt( os.path.join( idir, 'Bessel_I.dat' ) )
    Iband[:,0] /= 1e4 # convert from Angstrom to micron.    
    Tband = np.loadtxt( tessPath, delimiter=',' )
    Tband[:,0] /= 1e3 # convert from nm to micron.
    Jband = np.loadtxt( os.path.join( idir, '2MASS_J.dat' ) )
    Jband[:,0] /= 1e3 # convert from nm to micron.
    Hband = np.loadtxt( os.path.join( idir, '2MASS_H.dat' ) )
    Hband[:,0] /= 1e3 # convert from nm to micron.
    Kband = np.loadtxt( os.path.join( idir, '2MASS_Ks.dat' ) )
    Kband[:,0] /= 1e3 # convert from nm to micron.
    if makePlot:
        plt.figure()
        z = [ [Vband,'V'], [Iband,'I'], [Tband,'T'], \
              [Jband,'J'], [Hband,'H'], [Kband,'K'] ]
        for i in z:
            plt.plot( i[0][:,0], i[0][:,1]/i[0][:,1].max(), label=i[1] )
        plt.legend()
    return Vband, Iband, Tband, Jband, Hband, Kband


def modelStellarSpectrum( TeffK, loggCGS, FeH=0 ):
    if TeffK<3500:
        print( '  WARNING: set Teff={0:.0f}K --> Teff=3500K'.format( TeffK ) )
        TeffK = 3500
    if loggCGS>5:
        print( '  WARNING: set logg={0:.3f} --> logg=5'.format( loggCGS ) )
        loggCGS = 5
    sp = pysynphot.Icat( 'k93models', TeffK, FeH, loggCGS )
    sp.convert( pysynphot.units.Angstrom )
    sp.convert( pysynphot.units.Photlam )
    wavAngstrom = sp.wave
    wavMicr = wavAngstrom*(1e-4)
    F = sp.flux*wavAngstrom
    star = [ wavMicr, F ]
    return star


def JHKVmags( TICIDs ):
    

    listtici = list( TICIDs )
    
    def mast_query( request ):
          """
          Perform a MAST query.
        
              Parameters
              ----------
              request (dictionary): The MAST request json object
            
          Returns head,content where head is the response HTTP headers, and content is the returned data
          """
        # Base API url
          request_url='https://mast.stsci.edu/api/v0/invoke'
        
        # Grab Python Version
          version =".".join(map(str, sys.version_info[:3]))
        
        # Perform the HTTP request
          headers = {'Content-type': 'application/x-www-form-urlencoded',
                    'Accept': 'text/plain',
                    'User-agent':'python-requests/'+version}
        
        # Encoding the request as a json string
          req_string = json.dumps(request)
          req_string = urlencode(req_string)
        
        # Perform the HTTP request
          resp = requests.post(request_url, data='request='+req_string, headers=headers)
         
        # Pull out the headers and response content
          head = resp.headers
          content = resp.content.decode('utf-8') 
    
          return head, content
    
    request = {'service':'Mast.Catalogs.Filtered.Tic', 'format':'json', \
                                              'params':{'columns':'rad, mass', \
                                              'filters':[{'paramName':'ID', 'values':listtici}]}}
    headers, outString = mast_query( request )
    dictquertemp = json.loads( outString )['data']
    
    magsDictByID = {}
    
    for planet in dictquertemp:
        magsDictByID[planet['ID']] = {'Jmag':planet['Jmag'],'Hmag':planet['Hmag'],\
                                      'Kmag':planet['Kmag'],'Vmag':planet['Vmag'], \
                                       'Imag':planet['imag'] }
    
    magsDict = {}
    mags = ['Jmag', 'Hmag', 'Kmag', 'Vmag', 'Imag']
    
    for mag in mags:
        maglist = []
        for TICID in listtici:
            planet = magsDictByID[int( TICID )]
            maglist.append( planet[mag] )
        magsDict[mag] = np.array( maglist, dtype=float )
    
    return magsDict


def tickLogFormat( y, pos ):
    # Find the number of decimal places required
    decimalplaces = int(np.ceil(np.maximum(-np.log10(y),0))) # =0 for numbers >=1
    # Insert that number into a format string
    formatstring = '{{:.{:1d}f}}'.format(decimalplaces)
    # Return the formatted tick label
    return formatstring.format(y)


def testWASP121():
    Vmag = 10.51
    Jmag = 9.625
    Kmag = 9.374
    TeffK = 6500.
    loggCGS = 4.5
    Jest = convertMag( Vmag, TeffK, loggCGS, inputMag='V', outputMag='J' )
    Kest = convertMag( Vmag, TeffK, loggCGS, inputMag='V', outputMag='Ks' )
    print( Jmag, Jest )
    print( Kmag, Kest )
    return None

def convertMag( inMag, TeffK, loggCGS, inputMag='T', outputMag='J', vega=None, star=None ):
    """
    Routine to convert Tmag to JHK mag.

    For example:

    Kmag = Tmag + 2.5*log10( [ vega_K/vega_T ]*[ star_T/star_K ] )

    where vega_K/vega_T is flux of Vega in the K band relative to T band
    and star_K/star_T is flux of Vegathe star of interest in the K band 
    relative to T band.
    """

    # Read in spectra for Vega and the star of interest:
    # NOTE: This is the most time-consuming step.    
    t1 = time.time()
    if vega is None:
        vega = spectrumVega( makePlot=False )
    t2 = time.time()
    if star is None:
        star = modelStellarSpectrum( TeffK, loggCGS, FeH=0 )
    t3 = time.time()
    # Read in the photometric passbands:
    V, I, T, J, H, Ks = photBands()
    if inputMag=='V':
        inM = V
    elif inputMag=='T':
        inM = T
    elif inputMag=='J':
        inM = J
    if outputMag=='V':
        M = V
    elif outputMag=='I':
        M = I
    elif outputMag=='J':
        M = J
    elif outputMag=='H':
        M = H
    elif outputMag=='Ks':
        M = Ks

    # Interpolate the Vega spectrum onto the photometric passbands
    # and then sum to get the relative fluxes in each passband:
    t4 = time.time()
    Fvega_I = np.sum( inM[:,1]*np.interp( inM[:,0], vega[0], vega[1] ) )
    Fvega_M = np.sum( M[:,1]*np.interp( M[:,0], vega[0], vega[1] ) )
    
    # Do the same for the star of interest:
    t5 = time.time()
    Fstar_I = np.sum( inM[:,1]*np.interp( inM[:,0], star[0], star[1] ) )
    Fstar_M = np.sum( M[:,1]*np.interp( M[:,0], star[0], star[1] ) )

    t6 = time.time()
    # Use the relative brightnesses to convert from Tmag to the output magnitude:
    outMag = inMag + 2.5*np.log10( ( Fvega_M/Fvega_I )*( Fstar_I/Fstar_M ) )
    t7 = time.time()
    return outMag


def spectrumVega( makePlot=False ):
    sp = pysynphot.Icat( 'k93models', 9600, 0, 4.1 )
    sp.convert( pysynphot.units.Angstrom )
    sp.convert( pysynphot.units.Photlam )
    wavAngstrom = sp.wave
    wavMicr = wavAngstrom*(1e-4)
    F = sp.flux*wavAngstrom
    if makePlot:
        # Compare to observed/model Vega from HST calibration:
        ipath = os.path.join( os.environ['PYSYN_CDBS'], 'calspec', \
                              'alpha_lyr_stis_010.fits' )
        
        hst = pysynphot.FileSpectrum( ipath )
        plt.figure()
        plt.plot( wavMicr, F/F.max(), '-k', label='Kurucz model' )
        plt.plot( hst.wave/1e4, hst.flux/hst.flux.max(), '-r', label='HST cal' )
        plt.xlim( [ 0, 2 ] )
        plt.title( 'Vega' )
    return wavMicr, F
    
    

def densityContours():
    idir = os.path.dirname( __file__ )
    h2 = np.loadtxt( os.path.join( idir, 'contours_h2.txt' ) )
    h2o = np.loadtxt( os.path.join( idir, 'contours_h2o.txt' ) )
    mgsio3 = np.loadtxt( os.path.join( idir, 'contours_mgsio3.txt' ), skiprows=1 )
    fe = np.loadtxt( os.path.join( idir, 'contours_fe.txt' ), skiprows=1 )
    uM = 1 # ( MEARTH_SI/MJUP_SI )
    uR = 1 # ( REARTH_SI/RJUP_SI )
    h2[:,0] = h2[:,0]*uM
    h2[:,1] = h2[:,1]*uR
    h2o[:,0] = h2o[:,0]*uM
    h2o[:,1] = h2o[:,1]*uR
    mgsio3[:,0] = mgsio3[:,0]*uM
    mgsio3[:,1] = mgsio3[:,1]*uR
    fe[:,0] = fe[:,0]*uM
    fe[:,1] = fe[:,1]*uR
    return h2, h2o, mgsio3, fe

def readStellarTrack():
    d = np.loadtxt( 'ames_dusty_5Gyr.txt' )
    MsSI = d[:,0]*MSUN_SI
    TeffK = d[:,1]
    loggCGS = d[:,3]
    gCGS = 10**loggCGS
    gSI = gCGS/100.
    RsSI = np.sqrt( GRAV_SI*MsSI/gSI )
    RsRE = RsSI/REARTH_SI
    return RsRE, TeffK
    

def massRadiusChenKipping2017( RpRE_in ):
    """
    Evaluates the mean of the Chen & Kipping (2017) distribution.

    NOTE:
    The S3 index has been adjusted to be slightly positive. This
    is done purely for convenience, because otherwise it is not
    possible to quickly obtain a deterministic mass for a given
    radius, i.e. when there's a combination of negative and 
    positive indices there will be mass degeneracies for certain
    input radii.
    """
    
    # Power law indices:
    S1 = 0.2790
    S2 = 0.589
    #S3 = -0.044 # value quoted in Chen & Kipping (2017)
    S3 = 0.01 # mild tweak done purely for convenience
    S4 = 0.881
    # Other transition points from Table 1
    T12ME = np.log10( 2.04 )
    T23ME = np.log10( 0.414*( MJUP_SI/MEARTH_SI ) )
    T34ME = np.log10( 0.080*( MSUN_SI/MEARTH_SI ) )
    # Terran power law constant from Table 1:
    C1curl = np.log10( 1.008 )
    # Iteratively derive other power law constants:
    C2curl = C1curl + ( S1-S2 )*T12ME
    C3curl = C2curl + ( S2-S3 )*T23ME
    C4curl = C3curl + ( S3-S4 )*T34ME

    log10MpME = np.linspace( -3, 5, 1000 )

    log10M12 = np.log10( 2.04 )
    log10M23 = np.log10( 0.414*( MJUP_SI/MEARTH_SI ) )
    log10M34 = np.log10( 0.080*( MSUN_SI/MEARTH_SI ) )
    ixs1 = ( log10MpME<=log10M12 )
    ixs2 = ( log10MpME>log10M12 )*( log10MpME<=log10M23 )
    ixs3 = ( log10MpME>log10M23 )*( log10MpME<=log10M34 )
    ixs4 = ( log10MpME>log10M34 )


    log10RpRE = np.ones_like( log10MpME )
    log10RpRE[ixs1] = C1curl + ( log10MpME[ixs1]*S1 )
    log10RpRE[ixs2] = C2curl + ( log10MpME[ixs2]*S2 )
    log10RpRE[ixs3] = C3curl + ( log10MpME[ixs3]*S3 )
    log10RpRE[ixs4] = C4curl + ( log10MpME[ixs4]*S4 )

    log10MpME_out = np.interp( np.log10( RpRE_in ), log10RpRE, log10MpME )
    MpME_out = 10**log10MpME_out

    if 0:
        plt.figure()
        plt.plot( log10MpME[ixs1], log10RpRE[ixs1], '-r' )
        plt.plot( log10MpME[ixs2], log10RpRE[ixs2], '-k' )
        plt.plot( log10MpME[ixs3], log10RpRE[ixs3], '-g' )
        plt.plot( log10MpME[ixs4], log10RpRE[ixs4], '-c' )
       
        print( RpRE_in, MpME_out )
        pdb.set_trace()
        
    return MpME_out
    

def planetMassFromRadius( RpRE, whichRelation='Chen&Kipping2017' ):
    """
    Taken from Eq 2 of Kempton et al (2017).
    """
    if whichRelation=='Chen&Kipping2017':
        MpME = massRadiusChenKipping2017( RpRE )
    elif whichRelation=='Kempton+2018':
        if np.ndim( RpRE )==0:
            if RpRE<1.23:
                MpME = 0.9718*( RpRE**3.58 )
            elif ( RpRE>=1.23 )*( RpRE<30 ):
                MpME = 1.436*( RpRE**1.70 )
            else:
                print( '\n\nPlanet radius too large... {0:.1f}RE'.format( RpRE ) )
                MpME = np.nan
        else:
            MpME = np.zeros_like( RpRE )
            ixs1 = ( RpRE<1.23 )
            MpME[ixs1] = 0.9718*( RpRE[ixs1]**3.58 )
            ixs2 = ( RpRE>=1.23 )*( RpRE<14.26 )
            MpME[ixs2] = 1.436*( RpRE[ixs2]**1.70 )
            ixs3 = ( RpRE>=14.26 )
            MpME[ixs3] = np.nan
    return MpME


def solarSystem():
    z = {}
    z['TstarK'] = 5800.
    z['RsSI'] = RSUN_SI
    z['aAU'] = {}
    z['aAU']['Mercury'] = 0.3870993
    z['aAU']['Venus'] = 0.723336
    z['aAU']['Earth'] = 1.000003
    z['aAU']['Mars'] = 1.52371
    z['aAU']['Jupiter'] = 5.2029
    z['aAU']['Saturn'] = 9.537
    z['aAU']['Titan'] = z['aAU']['Saturn']
    z['aAU']['Uranus'] = 19.189
    z['aAU']['Neptune'] = 30.0699
    planets = list( z['aAU'].keys() )
    z['aSI'] = {}
    for k in planets:
        z['aSI'][k] = AU_SI*z['aAU'][k]
    z['aRs'] = {}
    for k in planets:
        z['aRs'][k] = z['aSI'][k]/z['RsSI']
    z['TeqK'] = {}
    for k in planets:
        z['TeqK'][k] = calcTeqK( z['TstarK'], z['aRs'][k] )
    z['RpSI'] = {}
    z['RpSI']['Mercury'] = ( 4879e3 )/2.
    z['RpSI']['Venus'] = ( 12104e3 )/2.
    z['RpSI']['Earth'] = ( 12756e3 )/2.
    z['RpSI']['Mars'] = ( 6792e3 )/2.
    z['RpSI']['Jupiter'] = ( 142984e3 )/2.
    z['RpSI']['Saturn'] = ( 120536e3 )/2.
    z['RpSI']['Titan'] = 2575e3
    z['RpSI']['Uranus'] = ( 51118e3 )/2.
    z['RpSI']['Neptune'] = ( 49528e3 )/2.
    z['RpRE'] = {}
    for k in planets:
        z['RpRE'][k] = z['RpSI'][k]/REARTH_SI

    return z


def computeTSM( RpValRE, MpValME, RsRS, TeqK, Jmag ):
    nAll = len( RpValRE )
    # Indices for different radii of each scale factor:
    ixsA = np.arange( nAll )[np.isfinite( RpValRE )]
    ixsB = np.arange( nAll )[np.isfinite( RpValRE )==False]
    ixs1 = ixsA[( RpValRE[ixsA]<1.5 )]
    ixs2 = ixsA[( RpValRE[ixsA]>=1.5 )*( RpValRE[ixsA]<2.75 )]
    ixs3 = ixsA[( RpValRE[ixsA]>=2.75 )*( RpValRE[ixsA]<4.0 )]
    ixs4 = ixsA[( RpValRE[ixsA]>=4.0 )*( RpValRE[ixsA]<10. )]
    ixs5 = ixsA[( RpValRE[ixsA]>=10 )]
    # Scale factors provided in Table 1 of Kempton et al (2018):
    c1 = 0.190
    c2 = 1.26
    c3 = 1.28
    c4 = 1.15
    c5 = 1.15 # had previously set this to 1.0
    # TSM before applying scale factor:
    Rp3 = RpValRE**3.
    MpRs2 = MpValME*( RsRS**2. )
    y = ( Rp3*TeqK/MpRs2 )*( 10**( -Jmag/5. ) )
    TSM = np.zeros( nAll )
    TSM[ixs1] = c1*y[ixs1]
    TSM[ixs2] = c2*y[ixs2]
    TSM[ixs3] = c3*y[ixs3]
    TSM[ixs4] = c4*y[ixs4]
    TSM[ixs5] = c5*y[ixs5]
    TSM[ixsB] = np.nan
    return TSM


def computeESM( TeqK, RpRs, TstarK, Kmag ):
    wavRefSI = 7.5e-6
    TdayK = 1.10*TeqK # from Section 3.2 of Kempton+2018
    Bday =  PlanckFuncSI( wavRefSI, TdayK )
    Bstar =  PlanckFuncSI( wavRefSI, TstarK )
    ESM = 4.29*(1e6)*( Bday/Bstar )*( RpRs**2. )*( 10**( -Kmag/5. ) )
    return ESM


def PlanckFuncSI( wavSI, T ):
    """
    Returns the Planck spectrum in cgs units given 
    a wavelength range and temperature.
    """
    hSI = np.longdouble( 6.62607015e-34 ) # Planck constant (J*s)
    cSI = np.longdouble( 2.9979245800e8 ) # speed of light (m/s)
    kSI = np.longdouble( 1.380649e-23 ) # Boltzman constant (J/K)
    c0 =  2.*hSI*( cSI**2. )/( wavSI**5. )
    c1 = hSI*cSI/kSI/T
    irrSI = c0/( np.exp( c1/wavSI ) - 1. ) # radiance
    fluxSI = np.pi*irrSI*wavSI # surface flux
    return fluxSI


def calcTeqK( TstarK, aRs ):
    TeqK = ( TstarK/np.sqrt( aRs ) )*( 0.25**0.25 )
    return TeqK


def getThresholdTSM_REDUNDANT( RpRE, framework='ACWG' ):
    """
    Thresholds from Figure 5 of Kempton et al. (2018).
    """
    if framework=='ACWG':
        if RpRE<1.50: # 1. Terrestrials
            return 10
        elif ( RpRE>=1.50 )*( RpRE<2.75 ): # 2. Small sub-Neptunes
            return 90
        elif ( RpRE>=2.75 )*( RpRE<4.00 ): # 3. Large sub-Neptunes
            return 90
        elif ( RpRE>=4.00 )*( RpRE<10.00 ): # 4. Sub-Jovians
            return 90
        elif ( RpRE>=10.00 ): # 5. Gas giants
            return 100
    elif framework=='TOIs':
        if RpRE<1.50: # 1. Terrestrials
            return 10
        else:
            return 50 # 2. Everything else

    

def getRARanges():
    m = 4
    RAedges = np.arange( 0, 24+m, m )
    n = len( RAedges )-1
    RARanges = []
    for i in range( n ):
        RARanges += [ [ RAedges[i], RAedges[i+1] ] ]
    return RARanges
    
def getRARange( month ):
    # RAmid is approximately the sidereal angle (i.e. overhead RA) at
    # midnight on the 20th day of the month.
    if month=='Jan':
        RAmid = 8
    elif month=='Feb':
        RAmid = 10
    elif month=='Mar':
        RAmid = 12
    elif month=='Apr':
        RAmid = 14
    elif month=='May':
        RAmid = 16
    elif month=='Jun':
        RAmid = 18
    elif month=='Jul':
        RAmid = 20
    elif month=='Aug':
        RAmid = 22
    elif month=='Sep':
        RAmid = 0
    elif month=='Oct':
        RAmid = 2
    elif month=='Nov':
        RAmid = 4
    elif month=='Dec':
        RAmid = 6
    dRA = 6 # +/- RA hr from overhead at midnight.
    RARange = [ RAmid-dRA, RAmid+dRA ]
    return RARange


def processRARestriction( RAMin_hr, RAMax_hr ):
    if ( RAMin_hr is not None )*( RAMax_hr is not None ):
        RAStr = '{0:.0f}<RA(hr)<{1:.0f}'.format( RAMin_hr, RAMax_hr )
    elif ( RAMin_hr is not None )+( RAMax_hr is not None ):
        if RAMin_hr is None:
            RAMin_hr = -1e9 
            RAStr = 'Only RA(hr)<{0:.1f} targets'.format( RAMax_hr )
        else:
            RAMax_hr = 1e9
            RAStr = 'Only RA(hr)>{0:.0f} targets'.format( RAMin_hr )
    else:
        RAMin_hr = -1e9 
        RAMax_hr = 1e9
        RAStr = 'No RA restrictions applied'
    return RAStr, RAMin_hr, RAMax_hr


def processDecRestriction( DecMin_deg, DecMax_deg ):
    if ( DecMin_deg is not None )*( DecMax_deg is not None ):
        DecStr = '{0:.0f}<Dec(deg)<{1:.0f}'.format( DecMin_deg, DecMax_deg )
    elif ( DecMin_deg is not None )+( DecMax_deg is not None ):
        if DecMin_deg is None:
            DecMin_deg = -1e9 
            DecStr = 'Only Dec(deg)<{0:.0f} targets'.format( DecMax_deg )
        else:
            DecMax_deg = 1e9
            DecStr = 'Only Dec(deg)>{0:.0f} targets'.format( DecMin_deg )
    else:
        DecMin_deg = -1e9 
        DecMax_deg = 1e9
        DecStr = 'No Dec restrictions applied'
    return DecStr, DecMin_deg, DecMax_deg


def getStarColor( T ):
    if ( T<3400 ): # late-M
        c = np.array( [178,24,43] )/256.
    elif ( T>=3400 )*( T<3800 ): # early-M
        c = np.array( [252,78,42] )/256.
    elif ( T>=3800 )*( T<4600 ): # late-K
        c = np.array( [253,141,60] )/256.
    elif ( T>=4600 )*( T<5200 ): # early-K
        c = np.array( [254,178,76] )/256.
    elif ( T>=5200 )*( T<5700 ): # late-G
        c = np.array( [254,217,118] )/256.
    elif ( T>=5700 )*( T<6000 ): # early-G
        c = np.array( [255,237,160] )/256.
    elif ( T>=6000 )*( T<6700 ): # late-F
        c = np.array( [158,202,225] )/256.
    elif ( T>=6700 )*( T<7400 ): # early-F
        c = np.array( [107,174,214] )/256.
    else: # OBA
        c = np.array( [8,81,156] )/256.
    return c
        
def getAllStarColors():
    c = {}
    c['late-M'] = getStarColor( 3200 )
    c['early-M'] = getStarColor( 3600 )
    c['late-K'] = getStarColor( 4000 )
    c['early-K'] = getStarColor( 4800 )
    c['late-G'] = getStarColor( 5500 )
    c['early-G'] = getStarColor( 5900 )
    c['late-F'] = getStarColor( 6500 )
    c['early-F'] = getStarColor( 7200 )
    c['OBA'] = getStarColor( 7500 )
    
    SpTs = [ 'late-M', 'early-M', 'late-K', 'early-K', \
             'late-G', 'early-G', 'late-F', 'early-F', 'OBA' ]
    return c, SpTs

def computeStellarMass( RsRS, loggstarCGS ):

    gStarSI = 10**loggstarCGS / 100 # converts log(g)[cm/s^2] to g [m/s^2]
    RsRS = RsRS * RSUN_SI # converts stellar radius from solar unit to SI 
    MsMS = gStarSI * RsRS**2 / GRAV_SI
    MsMS /= MSUN_SI # converts stellar mass to solar unit
    
    return MsMS

def computeRVSemiAmp( Pday, MpME, MsMS ):
    """
    Returns RV semi-amplitude in m/s.
    Equation from: https://exoplanetarchive.ipac.caltech.edu/docs/poet_calculations.html
    """
    MpMJ = MpME * MEARTH_SI / MJUP_SI # converts mass from Earth unit to Jupiter unit
    i = math.pi/2
    e = 0
    
    K = 203 * (Pday)**(-1/3) * \
        ((MpMJ * math.sin(i)) / (MsMS + 9.458e-4 * (MpMJ)**(2/3))) * \
        (1 / (1 - e**2)**(1/2))
    return K

def TeqK_Kempton (Pday, MsMS, TstarK, RsRS):
    """
    Computes TeqK values based on Kempton assuming a circular orbit.
    """
    Psec = Pday*24*3600
    MsSI = MsMS * MSUN_SI
    RsSI = RsRS * RSUN_SI

    aSI = (GRAV_SI * MsSI * Psec**2/(4*np.pi**2))**(1/3)

    TeqK = TstarK * (RsSI/aSI)**(1/2) * (1/4)**(1/4)
    aRs = aSI/RsSI
    return TeqK, aRs

def HeatMapValues(TRange, RRange, TeqK, RpValRE, predTeqK, predRpVal):
    TOI_TeqK = list(TeqK[:])
    TOI_Rp = list(RpValRE[:])
    pred_TeqK = list(predTeqK[:])
    pred_Rp = list(predRpVal[:])
    
    TOI_n = 0
    for i in range(len(TOI_TeqK)): #Check if TOI is in box, if so then add one to TOI_n
        if TRange[0] <= TOI_TeqK[i] <= TRange[1] and RRange[0] <= TOI_Rp[i] <= RRange[1]:
            TOI_n += 1

    pred_n = 0
    for i in range(len(pred_TeqK)): #Check if pred is in box, if so then add one to pred_n
        if TRange[0] <= pred_TeqK[i] <= TRange[1] and RRange[0] <= pred_Rp[i] <= RRange[1]:
            pred_n += 1

    #Generate fraction of TOIs, pred
    TOI_frac = TOI_n/len(TOI_TeqK)
    pred_frac = pred_n/len(pred_TeqK)
    if pred_frac == 0: #Prevents divide by zero error
        pred_frac = 1
    #Final value is ratio of fraction of TOIs to pred
    value = TOI_frac/pred_frac
    return value

def Normalize(values, clip, scaled=True):
    box_avg = np.average(values)
    box_std = np.std(values)
    box_values3 = list(values)
    
    for value in values:
        if np.abs(value-box_avg) > 3*box_std:
            box_values3.remove(value)
        elif not np.isfinite(value):
            box_values3.remove(value)

    minVal = np.min(box_values3)
    maxVal = np.max(box_values3)
    box_norm = []
    for value in values:
        if not np.isfinite(value):
            norm = 0.9999 #If zero TOIs in box, box gets colored white
        elif value <= 0: #If TOI fraction < pred fraction, box colored cool
            norm = 0.99*(value - minVal)/(0 - minVal)*0.5
            if norm < 0:
                norm = 0 
        elif value > 0: #If TOI fraction > pred fraction, box colored warm
            norm = 0.5 + 0.99*value/maxVal*0.5
            if norm > 1:
                norm = 0.99 
        box_norm.append(norm)
    return box_norm


def addThresholdPasses( z, survey, SMFlag, framework ):
    """
    Add an array of 0s and 1s to the dictionary z, specifying
    whether or not each target meets the minimum TSM/ESM
    threshold for the given survey (i.e. Rp-Teq divisions) under
    the given framework (e.g. Kempton et al., 2018).
    """
    if SMFlag=='TSM':
        threshFunc = survey['thresholdTSM']
    elif SMFlag=='ESM':
        threshFunc = survey['thresholdESM']
    n = len( z['planetName'] )
    z['thresholdPass'] = np.zeros( n, dtype=int )
    for i in range( n ):
        RpRE = z['RpValRE'][i]
        TeqK = z['TeqK'][i]
        SMthresh, SMstr = threshFunc( RpRE, TeqK, framework=framework )
        if z['SM'][i]>SMthresh:
            z['thresholdPass'][i] = 1
    return z
